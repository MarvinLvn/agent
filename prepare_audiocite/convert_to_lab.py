import os
import pandas as pd
import argparse
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.stats import norm
import scipy.stats as stats
import numpy as np
FRAME_LENGTH = 0.02 # in seconds
DEBUG = False
NB_DEBUG = 200

PHONE_MAP = {
    'a': 'a',
    'p': 'p',
    'ʁ': 'r',
    'ɛ': 'e^',
    'l': 'l',
    'e': 'e',
    'z': 'z',
    'f': 'f',
    'd': 'd',
    'ə': 'q',
    'u': 'u',
    't': 't',
    'i': 'i',
    'n': 'n',
    'm': 'm',
    'ɑ̃': 'a~',
    's': 's',
    'ɛ̃': 'x~',
    'k': 'k',
    'y': 'y',
    'v': 'v',
    'o': 'o',
    'j': 'j',
    'ɔ̃': 'o~',
    'b': 'b',
    'ʒ': 'z^',
    'œ': 'x^',
    'w': 'w',
    'ɔ': 'o^',
    'ɡ': 'g',
    'œ̃': 'e~',
    'ø': 'x',
    'ʃ': 's^',
    'aː': 'a',
    '(en)': '_',
    'ɑː': 'a',
    'ð': 'ð',# the English 'th', should be removed from ABX tests
    '(fr)': '_',
    'oː': 'o',
    'ɲ': 'ɲ', # as in 'oiGNon', I don't think this sound is in pb2009
    'yː': 'y',
    'ɔː': 'o^',
    'dʒ': 'dʒ', # as in 'Journal' (English), not a French sound
    'h': 'h', # as in 'Hello' (English), not a French sound
    'uː': 'u',
    'ɪ': 'i', # as in 'petite' (French Quebec), allophone of /i/
    'iː': 'i',
    'ɒ': 'a',
    'ɹ': 'ɹ', # as in 'right' (English), not a French sound
    'eɪ': 'eɪ', # as in 'day' (English), not a French sound
    'ɜː': 'x^',
    'ŋ': 'ŋ', # as in 'campinG', occurs only in words borrowed from English
    'ʊ': 'u', # as in 'foule' (French Quebec), allophone of /u/
    'ʌ': 'o^',
    'θ': 'θ', # as in 'thin' (English), not a French sound
    'øː': 'x',
    'əʊ': 'əʊ', # as in 'bow' (English), not a French sound
    'aʊ': 'aʊ', # all sounds below are kept as is but are super infrequent
    'ʊə': 'ʊə',
    'aɪ': 'aɪ',
    'ɐ': 'ɐ',
    'tʃ': 'tʃ',
    'iə': 'iə',
    'ɔɪ': 'ɔɪ',
    'əl': 'əl',
    'eə': 'eə',
    'r': 'r'
}

def load_all_csv(data_path):
    all_data = pd.DataFrame()
    for i, csv_path in enumerate(data_path.glob('*.csv')):
        data = pd.read_csv(csv_path, sep='\t')[['phone', 'start', 'end']]
        data['file'] = csv_path.stem
        all_data = pd.concat([all_data, data], ignore_index=True)
        if DEBUG and i == NB_DEBUG:
            all_data['duration'] = all_data['end'] - all_data['start']
            return all_data
    all_data['duration'] = all_data['end'] - all_data['start']
    return all_data

def clean_durations(data):
    '''
    For each phone, we "fit" a Gaussian distribution on that phone's durations.
    All durations greater than mu + 3 * std are brought back to the mean.
    Note that Gaussians are fitted in a way that is robust to outliers since we take:
    1) mu = median
    2) std = 1.4826 * median absolute deviation (robust estimate of std)

    :param data: The forced aligned phone transcript (pandas dataframe)
    :return: The forced aligned phone transcript with fixed durations
    '''
    phones = data['phone'].unique()
    for phone in phones:
        # 1) Fit Gaussian
        durations = data[data['phone'] == phone]['duration']
        mu = durations.median()
        mad = np.median(np.abs(durations - durations.median()))
        std = 1.4826 * mad
        # 2) Bring back outliers to the mean
        outliers_mask = (data['phone'] == phone) & (data['duration'] > mu + 3 * std)
        data.loc[outliers_mask, 'duration'] = mu

    data['start'] = (data['start'] / FRAME_LENGTH).astype(int)
    data['end'] = (data['end'] / FRAME_LENGTH).astype(int)
    return data

def map_phone(data):
    data['phone'] = data['phone'].map(lambda x: PHONE_MAP[x])
    return data

def write_lab(data, out_folder):
    filenames = data['file'].unique()
    for filename in filenames:
        sub = data[data['file'] == filename]
        sub = sub[['start', 'end', 'phone']]
        out_path = out_folder / (filename + '.lab')
        sub.to_csv(out_path, sep=' ', header=False, index=False)

def main():
    parser = argparse.ArgumentParser(description="Convert phone CSV files to LAB files.")
    parser.add_argument("--data_path", type=str, required=True,
                        help="Path to the folder containing CSV files (generated by apply_whisper.py")
    args = parser.parse_args()

    data_path = Path(args.data_path)
    out_folder = data_path.parent / 'lab'
    out_folder.mkdir(exist_ok=True)

    data = load_all_csv(data_path)
    data = clean_durations(data)
    data = map_phone(data)
    write_lab(data, out_folder)

    print("Conversion completed.")


if __name__ == "__main__":
    main()